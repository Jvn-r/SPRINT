<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Process Visualizer+</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>

    body {
      margin: 0;
      background: #111;
      overflow: hidden;
    }

    text {
      font-size: 12px;
      fill: #0f0;
      font-family: monospace;
    }

    circle {
      stroke: #fff;
      stroke-width: 1.5px;
    }

    #controls {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.7);
      color: #0f0;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      border: 1px solid #0f0;
      border-radius: 5px;
    }

    #controls button, #controls label {
      background: #222;
      color: #0f0;
      border: 1px solid #0f0;
      margin: 2px;
      padding: 3px 5px;
      font-family: monospace;
      cursor: pointer;
    }

    #controls input {
      margin-right: 4px;
    }

  </style>
</head>
<body>

  <!-- control panel ui -->
  <div id="controls">
    <div>
      <button id="pauseBtn">Pause</button>
      <button id="clearBtn">Clear</button>
    </div>
    <div>
      <label><input type="checkbox" value="FileIO" checked> FileIO</label>
      <label><input type="checkbox" value="Registry"> Registry</label>
      <label><input type="checkbox" value="Network"> Network</label>
    </div>
    <div id="stats">Events: 0 | Nodes: 0 | Links: 0</div>
  </div>

  <svg width="100%" height="100%"></svg>

  <script>
    //find the svg element thru d3 and then set their sizes
    const svg = d3.select("svg")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight);

    const width = +svg.attr("width");
    const height = +svg.attr("height");
    const g = svg.append("g");

    //creating separate layers so process nodes always sit on top of link edges
    const linkLayer = g.append("g").attr("class", "links");
    const nodeLayer = g.append("g").attr("class", "nodes");

    //setup zooming and panning
    const zoom = d3.zoom()
      .scaleExtent([0.1, 4]) //zoom 10% to 400%
      .on("zoom", (event) => {
        g.attr("transform", event.transform);
    });
    svg.call(zoom);

    //this is for the physics part, this just says;
    //pull connected nodes to 120 px distance, adds a repulsive force to each node so they dont overlap, and keeps layout centered
    const simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(d => d.id).distance(120))
        .force("charge", d3.forceManyBody().strength(-400))
        .force("center", d3.forceCenter(width / 2, height / 2));
        
    //simple graph model w nodes and links
    let graph = { nodes: [], links: [] };

    function linkKey(d) {
      const sid = d.source.id ? d.source.id : d.source;
      const tid = d.target.id ? d.target.id : d.target;
      return sid + "->" + tid;
    }

    function update() {
      //links
      const link = linkLayer.selectAll(".link")
        .data(graph.links, linkKey);
      
      link.enter().append("line")
        .attr("class", "link")
        .merge(link)
        .attr("stroke", d => {
          switch (d.severity) {
            case "high": return "red";
            case "medium": return "orange";
            case "low": return "green";
            default: return "#0f0"; 
          }
        })
        .attr("stroke-width", d => Math.min(6, (d.weight || 1) ** 0.7));
      //creates new lines for new links and styles them and merges them to link

      link.exit().remove();
      //Removes any elements that no longer exist

      //nodes
      const node = g.selectAll(".node")
        .data(graph.nodes, d => d.id);

      const nodeEnter = node.enter().append("g")
        .attr("class", "node")
        .call(d3.drag()
          .on("start", dragStarted)
          .on("drag", dragged)
          .on("end", dragEnded));
        //Handlers for dragging

      nodeEnter.append("circle")
        .attr("r", 20)
        .attr("fill", d => d.type === "process" ? "steelblue" : "orange");

      nodeEnter.append("text")
        .attr("dy", -25)
        .attr("text-anchor", "middle")
        .text(d => d.label);

      node.exit().remove();

      //give new data to simulation
      simulation
        .nodes(graph.nodes)
        .on("tick", ticked);
      simulation.force("link")
        .links(graph.links);

      simulation.alpha(1).restart();
      //resets the simulation

      function ticked() {
        g.selectAll(".link")
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        g.selectAll(".node")
          .attr("transform", d => `translate(${d.x},${d.y})`);
      }
    }

    //Dragging functions
    function dragStarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragEnded(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    //this creates the edges bw proc node and file node
    function addEdge(procName, pid, filePath, action, severity) {
      const procId = `${procName}#${pid}`; //unique id with proc name + proc id, to diff bw diff process w same name and diff proc ids
      const fileId = filePath;

      upsertNode(procId, `${procName} (${pid})`, "process"); //ensures node exists
      const fileLabel = filePath.split("\\").pop(); 
      upsertNode(fileId, fileLabel, "file");

      upsertLink(procId, fileId, action, severity);
    }

    //looks for an existing node w same id, if doesnt exist creates a new node obj
    function upsertNode(id, label, type) {
      let n = graph.nodes.find(x => x.id === id);
      if (!n) {
        n = { id, label, type };
        graph.nodes.push(n);
      }
      return n;
    }
    
    //makes sure the connection bw the source(process) and target(files) exists, it checks the existing graph if that connection exists, if not creates and pushes it to graph
    function upsertLink(sourceId, targetId, action, severity="info") {
      let l = graph.links.find(l => 
        (l.source.id || l.source) === sourceId &&
        (l.target.id || l.target) === targetId
      );
      if (!l) {
        l = { source: sourceId, target: targetId, action, weight: 1, lastSeen: Date.now(), severity };
        graph.links.push(l);
      } else {
        l.weight = (l.weight || 1) + 1;
        l.lastSeen = Date.now();
        l.severity = severity; //overwrite severity with latest update
      }
      return l;
    }

    //state for events/filters/queue
    let queue = [];
    let connected = false;
    let paused = false;
    let filters = new Set(["FileIO"]); //start w FileIO only
    let stats = { events: 0, nodes: 0, links: 0 };

    //attach control buttons to their fucntions
    //pause
    document.getElementById("pauseBtn").onclick = () => {
      paused = !paused;
      document.getElementById("pauseBtn").innerText = paused ? "Resume" : "Pause";
    };
    
    //clear screen
    document.getElementById("clearBtn").onclick = () => {
      graph.nodes = [];
      graph.links = [];
      stats = { events: 0, nodes: 0, links: 0 };
      update();
      updateStats();
    };

    //preset filters
    document.querySelectorAll("#controls input[type=checkbox]").forEach(cb => {
      cb.addEventListener("change", () => {
        if (cb.checked) filters.add(cb.value);
        else filters.delete(cb.value);
        console.log("Filters now:", [...filters]);
        //send filter updates to server
        if (socket && connected) {
          socket.send(JSON.stringify({ type:"filters", categories:[...filters] }));
        }
      });
    });

    //aggregate fns for stats
    function updateStats() {
      document.getElementById("stats").innerText =
        `Events: ${stats.events} | Nodes: ${graph.nodes.length} | Links: ${graph.links.length}`;
    }

    //websockets stuff, like creating a handshake bw this and parser.js, sending filters back to parser.js
    let socket;
    function connectWS() {
      socket = new WebSocket("ws://localhost:8080");

      socket.addEventListener("open", () => {
        connected = true;
        console.log("WS connected");
        //sending initial filters
        socket.send(JSON.stringify({ type:"filters", categories:[...filters] }));
      });

      socket.addEventListener("message", (event) => {
        try {
          const ev = JSON.parse(event.data);

          if (ev.type === "stats") {
            stats.events = ev.events;
            updateStats();
          }
          else if (ev.type === "ProcessBatch") {
            //to get a bundle of events for one process
            for (const e of ev.events) {
              if (!paused && filters.has(e.category)) {
                queue.push(e);
                stats.events++;
              }   
            }
          }
          else if (ev.category && !paused && filters.has(ev.category)) {
            //single event mode
            queue.push(ev);
            stats.events++;
          }
        } catch (e) {
          //ignore non-JSON
        }
      });

      //when websocket is closed it'll be known here
      socket.addEventListener("close", () => {
        connected = false;
        console.warn("WS closed. Reconnecting in 2sâ€¦");
        setTimeout(connectWS, 2000);
      });

      //same thing for error encountered by websockets
      socket.addEventListener("error", () => {
        socket.close();
      });
    }
    connectWS();

    //checking every 0.1s if new events came in, if yes update graph, taking 200 events from the queue at a time
    setInterval(() => {
      if (!queue.length || paused) return;
      const batch = queue.splice(0, 200); //cap batch size to 200
      for (const ev of batch) {
        addEdge(ev.processName, ev.processId, ev.targetShort || ev.target, ev.operation, ev.severity);
      }
      update();
      updateStats();
    }, 100);

  </script
</body>
</html>
